package codec

import (
	"bytes"
	"fmt"
	"reflect"
	"testing"
)

var vps []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0C, 0x01,
	0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00,
	0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x78, 0x99, 0x98, 0x09}

var vps2 []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0C, 0x01,
	0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00,
	0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
	0x78, 0x99, 0x98, 0x0A}

var sps []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x01,
	0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x78, 0xA0, 0x03,
	0xC0, 0x80, 0x10, 0xE5, 0x96, 0x66, 0x69, 0x24,
	0xCA, 0xF0, 0x10, 0x10, 0x00, 0x00, 0x06, 0x40,
	0x00, 0x00, 0xBB, 0x50, 0x80}

var h265sps2 []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x01,
	0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00,
	0x03, 0x00, 0x00, 0x03, 0x00, 0x78, 0x50, 0x03,
	0xC0, 0x80, 0x10, 0xE5, 0x96, 0x66, 0x69, 0x24,
	0xCA, 0xF0, 0x10, 0x10, 0x00, 0x00, 0x06, 0x40,
	0x00, 0x00, 0xBB, 0x50, 0x80}

var pps []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0xC1, 0x72, 0xB4, 0x62, 0x40}

var pps2 []byte = []byte{0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0x48, 0x72, 0xB4, 0x62, 0x40}

var src []byte = []byte{
	0x01, 0x01, 0x60, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb4, 0xf0, 0x00,
	0xfc, 0xfd, 0xf8, 0xf8, 0x00, 0x00, 0x0f, 0x03, 0xa0, 0x00, 0x01, 0x00, 0x18, 0x40, 0x01,
	0x0c, 0x01, 0xff, 0xff, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x80, 0x00, 0x00, 0x03, 0x00,
	0x00, 0x03, 0x00, 0xb4, 0x9d, 0xc0, 0x90, 0xa1, 0x00, 0x01, 0x00, 0x29, 0x42, 0x01, 0x01,
	0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0xb4,
	0xa0, 0x01, 0xe0, 0x20, 0x02, 0x1c, 0x59, 0x67, 0x79, 0x24, 0x6d, 0xae, 0x01, 0x00, 0x00,
	0x03, 0x03, 0xe8, 0x00, 0x00, 0x5d, 0xc0, 0x08, 0xa2, 0x00, 0x01, 0x00, 0x06, 0x44, 0x01,
	0xc1, 0x73, 0xd1, 0x89}

var dst []byte = []byte{
	0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c, 0x01, 0xff, 0xff, 0x01, 0x60, 0x00, 0x00, 0x03,
	0x00, 0x80, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0xb4, 0x9d, 0xc0, 0x90, 0x00, 0x00,
	0x00, 0x01, 0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x80, 0x00, 0x00, 0x03,
	0x00, 0x00, 0x03, 0x00, 0xb4, 0xa0, 0x01, 0xe0, 0x20, 0x02, 0x1c, 0x59, 0x67, 0x79, 0x24,
	0x6d, 0xae, 0x01, 0x00, 0x00, 0x03, 0x03, 0xe8, 0x00, 0x00, 0x5d, 0xc0, 0x08, 0x00, 0x00,
	0x00, 0x01, 0x44, 0x01, 0xc1, 0x73, 0xd1, 0x89}

func TestVPS_Decode(t *testing.T) {
	type args struct {
		nalu []byte
	}
	tests := []struct {
		name string
		args args
	}{
		{name: "decode vps", args: args{nalu: vps}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			vps := &VPS{}
			start, sc := FindStartCode(tt.args.nalu, 0)
			ShowPacketHexdump(tt.args.nalu[start+int(sc):])
			vps.Decode(tt.args.nalu[start+int(sc):])
			t.Logf("%+v\n", vps)
		})
	}
}

func TestH265RawSPS_Decode(t *testing.T) {
	type args struct {
		nalu []byte
	}
	tests := []struct {
		name string
		args args
	}{
		{name: "decode sps", args: args{
			nalu: sps,
		}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rawsps := H265RawSPS{}
			start, sc := FindStartCode(tt.args.nalu, 0)
			rawsps.Decode(tt.args.nalu[start+int(sc):])
			t.Logf("%+v\n", rawsps)
		})
	}
}

func TestH265RawPPS_Decode(t *testing.T) {

	type args struct {
		nalu []byte
	}
	tests := []struct {
		name string
		args args
	}{
		{name: "decode pps", args: args{
			nalu: pps,
		}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rawpps := H265RawPPS{}
			start, sc := FindStartCode(tt.args.nalu, 0)
			rawpps.Decode(tt.args.nalu[start+int(sc):])
			t.Logf("%+v\n", rawpps)
		})
	}
}

func TestHevc_Update(t *testing.T) {
	t.Run("TestHevc_Update", func(t *testing.T) {
		hvcc := &HEVCRecordConfiguration{}
		hvcc.UpdateVPS(vps)
		hvcc.UpdateVPS(vps2)
		hvcc.UpdateSPS(sps)
		hvcc.UpdateSPS(h265sps2)
		hvcc.UpdatePPS(pps)
		hvcc.UpdatePPS(pps)
		hvcc.UpdatePPS(pps2)
		fmt.Printf("%+v\n", hvcc)
		for _, a := range hvcc.Arrays {
			fmt.Printf("%+v\n", *a)
			for _, n := range a.NalUnits {
				fmt.Printf("%+v\n", *n)
			}
		}
	})
}

func TestHEVCRecordConfiguration_Decode_Encode(t *testing.T) {
	type args struct {
		hevc []byte
	}
	tests := []struct {
		name string
		args args
	}{
		{name: "decode hevc", args: args{
			hevc: src,
		}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hvcc := &HEVCRecordConfiguration{}
			hvcc.Decode(tt.args.hevc)
			t.Logf("%+v\n", hvcc)
			for _, a := range hvcc.Arrays {
				t.Logf("%+v\n", *a)
				for _, n := range a.NalUnits {
					t.Logf("%+v\n", *n)
				}
			}
			b, _ := hvcc.Encode()
			ShowPacketHexdump(b)
			if !bytes.Equal(src, b) {
				t.Error("encode error")
			}
		})
	}
}

func TestHEVCRecordConfiguration_ToNalus(t *testing.T) {
	tests := []struct {
		name      string
		wantNalus []byte
	}{
		{name: "decode hevc", wantNalus: dst},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hvcc := &HEVCRecordConfiguration{}
			hvcc.Decode(src)
			if gotNalus := hvcc.ToNalus(); !reflect.DeepEqual(gotNalus, tt.wantNalus) {
				t.Errorf("HEVCRecordConfiguration.ToNalus() = %v, want %v", gotNalus, tt.wantNalus)
			}
		})
	}
}
